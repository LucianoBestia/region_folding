// region: lmake_readme include "readme.md" //! A
//
//! # lmake_readme  
//!
//! version: 0.5.2  date: 2020-04-24 authors: Luciano Bestia  
//! **Includes cargo.toml data into md and then the content of md files into src/*.rs files as doc comments for later documentation generation.**
//!
//!
//! First we want some data from cargo.toml to be included in the readme.md. To avoid data that is out of sync like version, authors and description.  
//! The we want to include the readme.md into the doc comments of the lib.rs or main.rs file.  
//! From this doc comments with `cargo doc` is then generated the documentation.  
//! We want to be all in sync with cargo.toml and readme.md.  
//! But also flexible to exclude what we don't need and to choose exactly where to include.  
//! The include can be executed many times, it will just replace the old content.  
//! The `lmake_readme` binary must be executed in the project root folder where is the cargo.toml file.  
//! It works only for single projects and not for workspaces.  
//!
//! ## install
//!
//! Install from crates.io:  
//! `cargo install lmake_readme`  
//! Then you can use it in every rust project folder.  
//! No arguments needed to execute the util.  
//! Try manually with --help to see if it works in the current folder:  
//! `lmake_readme --help`  
//!
//! ## Development
//!
//! Documentation:  
//! <https://lucianobestia.github.io/lmake_readme/>  
//! List of prepared make tasks for development: build, run, doc, publish,...  
//! `clear; cargo make`  
//!
//! ## include cargo.toml data into readme.md
//!
//! In the md file write these markers:  
//!
//! ```markdown
//! 1 [comment]: # (lmake_readme cargo.toml data start)
//! 2 [comment]: # (lmake_readme cargo.toml data end)
//! ```
//!
//! lmake_readme deletes the old lines between the markers  
//! and includes the date and the cargo.toml data:  
//! version, authors, description.  
//!
//! ## include md content to doc comments in rs files
//!
//! If you don't need all the content of the md file, you can exclude the lines
//! adding this markers:  
//!
//! ```markdown
//! 1 [comment]: # (lmake_readme exclude start A)  
//! 2 [comment]: # (lmake_readme exclude end A)  
//! ```
//!
//! In the rs file write these markers:  
//!
//! ```rust
//! 1 // region: lmake_readme include "filename.md" //! A  
//! 2 // endregion: lmake_readme include "filename.md" //! A  
//! ```
//!
//! lmake_readme deletes the old lines between the markers.  
//! Reads the filename of the md file to include. Exclude the eventual lines.  
//!
//! Before each line adds the doc comment symbol as is defined in the marker.  
//! includes the new lines between the markers in the rs file.  
//!
//! ## Tasks in Makefile.toml  
//!
//! I use `cargo make` to script the repetitive commands sequences.  
//! In `Makefile.toml` add a task like this:  
//!
//! ```toml
//! [tasks.doc]
//! description = "create docs from comments"
//! clear = true
//! dependencies = [
//!     "include-readme",
//!     "cargo-doc",
//!     "doc-copy",
//! ]
//!
//! [tasks.include-readme]
//! clear = true
//! private = true
//! description = "copy the content of readme.md into *.rs comments (for the docs)"
//! script= ["lmake_readme"]
//!
//! [tasks.cargo-doc]
//! clear = true
//! private = true
//! description = "call cargo doc"
//! command="cargo"
//! args=["doc","--no-deps","--document-private-items"]
//!
//! [tasks.doc-copy]
//! clear = true
//! private = true
//! description = "copy doc folder as docs (out of folder target), so it can be git committed"
//! script = [
//!     "\\rsync -avz --delete-after target/doc/*  docs/"
//! ]
//! ```
//!
// endregion: lmake_readme include "readme.md" //! A
// region: lmake_readme include "example.md" //! B
//!
//!
//! ## Example
//!
//! This project has a readme.md file and a src/main.rs file.  
//! You can have a look how the markers are used.  
//! In the beginning there is the `cargo.toml data` markers.  
//! At the end there is the `exclude` markers because we don't need the TODO section.  
//! In the main.rs there is the `region: lmake_readme include` markers.  
// endregion: lmake_readme include "example.md" //! B

// region: Clippy
#![warn(
    clippy::all,
    clippy::restriction,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo,
    // variable shadowing is idiomatic to Rust, but unnatural to me.
    clippy::shadow_reuse,
    clippy::shadow_same,
    clippy::shadow_unrelated,

)]
#![allow(
    // library from dependencies have this clippy warnings. Not my code.
    // Why is this bad: It will be more difficult for users to discover the purpose of the crate, 
    // and key information related to it.
    clippy::cargo_common_metadata,
    // Why is this bad : This bloats the size of targets, and can lead to confusing error messages when 
    // structs or traits are used interchangeably between different versions of a crate.
    clippy::multiple_crate_versions,
    // Why is this bad : As the edition guide says, it is highly unlikely that you work with any possible 
    // version of your dependency, and wildcard dependencies would cause unnecessary 
    // breakage in the ecosystem.
    clippy::wildcard_dependencies,
    // Rust is more idiomatic without return statement
    // Why is this bad : Actually omitting the return keyword is idiomatic Rust code. 
    // Programmers coming from other languages might prefer the expressiveness of return. 
    // It’s possible to miss the last returning statement because the only difference 
    // is a missing ;. Especially in bigger code with multiple return paths having a 
    // return keyword makes it easier to find the corresponding statements.
    clippy::implicit_return,
    // I have private function inside a function. Self does not work there.
    // Why is this bad: Unnecessary repetition. Mixed use of Self and struct name feels inconsistent.
    clippy::use_self,
    // Cannot add #[inline] to the start function with #[wasm_bindgen(start)]
    // because then wasm-pack build --target web returns an error: export run not found 
    // Why is this bad: In general, it is not. Functions can be inlined across crates when that’s profitable 
    // as long as any form of LTO is used. When LTO is disabled, functions that are not #[inline] 
    // cannot be inlined across crates. Certain types of crates might intend for most of the 
    // methods in their public API to be able to be inlined across crates even when LTO is disabled. 
    // For these types of crates, enabling this lint might make sense. It allows the crate to 
    // require all exported methods to be #[inline] by default, and then opt out for specific 
    // methods where this might not make sense.
    clippy::missing_inline_in_public_items,
    // Why is this bad: This is only checked against overflow in debug builds. In some applications one wants explicitly checked, wrapping or saturating arithmetic.
    // clippy::integer_arithmetic,
    // Why is this bad: For some embedded systems or kernel development, it can be useful to rule out floating-point numbers.
    clippy::float_arithmetic,
    // Why is this bad : Doc is good. rustc has a MISSING_DOCS allowed-by-default lint for public members, but has no way to enforce documentation of private items. This lint fixes that.
    clippy::doc_markdown,
    // Why is this bad : Splitting the implementation of a type makes the code harder to navigate.
    clippy::multiple_inherent_impl,

    clippy::missing_docs_in_private_items,
)]
// endregion

// region: mod, extern and use statements
mod includecargotomldatamod;
mod includereadmemod;
mod utilsmod;

#[macro_use]
extern crate unwrap;
extern crate clap;
extern crate glob;

#[allow(unused_imports)]
use ansi_term::Colour::{Green, Red, Yellow};
//use ansi_term::Style;
use clap::App;
use std::env;
// endregion

#[allow(clippy::print_stdout, clippy::integer_arithmetic)]
/// The program starts here. No arguments.
fn main() {
    // this function is different for Windows and for Linux.
    // Look at the code of this function (2 variations).
    enable_ansi_support();

    // define the CLI input line parameters using the clap library
    let _matches = App::new(env!("CARGO_PKG_NAME"))
        .version(env!("CARGO_PKG_VERSION"))
        .author(env!("CARGO_PKG_AUTHORS"))
        .about(env!("CARGO_PKG_DESCRIPTION"))
        .get_matches();

    let current_dir = unwrap!(env::current_dir());
    let current_dir = unwrap!(current_dir.to_str());
    println!("current_dir: {}", Yellow.paint(current_dir));

    includecargotomldatamod::include_cargo_toml_data_to_readme_md();
    includereadmemod::include_readme_md_to_rs_files();
}

// region: different function code for Linux and Windows
#[cfg(target_family = "windows")]
/// only on windows "enable ansi support" must be called
pub fn enable_ansi_support() {
    let _enabled = ansi_term::enable_ansi_support();
}

#[cfg(target_family = "unix")]
//on Linux "enable ansi support" must not be called
pub fn enable_ansi_support() {
    // do nothing
}
// endregion
